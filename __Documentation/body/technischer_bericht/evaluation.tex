\chapter{Evaluation}
\label{tb-evaluation}
An einem \brand{React Native} Meetup an der HSR konnten erste Entscheidungen zur Software-Entwicklungsumgebung und welche Lösungskonzepte es für die Darstellung der Karte gibt, geklärt werden.
Unter den vielen \brand{JavaScript}-Editoren haben wir uns für \brand{Atom} entschieden.
\brand{Facebook} hat für \brand{React Native} das \brand{Atom}-Package \brand{Nuclide}\footnote{\url{https://nuclide.io/}} veröffentlicht. 
\brand{Atom} ist Open Source und bietet viele weitere Community-Packages.

Weitere Hinweise zur Entwicklungsumgebung und den verwendeten Werkzeugen sind im Kapitel \nameref{pm-projektmanagement} beschrieben.

\section{Architektur}


\subsubsection{Variante A: flux-Architektur}


\subsubsection{Variante B: MVC}


\subsection{Fazit}



\section{App Navigation}
\begin{table}[H]
\centering
\label{tb-evaluation-app-navigation}
\begin{tabular}{|p{7cm}|p{7cm}|}
\hline
\multicolumn{2}{|c|}{\textbf{Variante A: \brand{React Native} Navigator-Komponente}} \\
\hline
Vorteile & Nachteile \\
\hline
\brand{Android} und \brand{iOS} Unterstützung 
& Schlechte Dokumentation zur Verwendung. \\
\hline
Flexibel und für einfache Use Cases gedacht
 & Schlecht erweiterbar für komplexere Use Cases in zukünftigen Versionen \\
\hline
\multicolumn{2}{|c|}{\textbf{Variante B: React-Native-Router-Flux\footnote{\url{https://github.com/aksonov/react-native-router-flux}}}} \\
\hline
Vorteile & Nachteile \\
\hline
Alle Views (Scenes) sind an einem Ort deklariert. 
Es müssen keine Navigator-Objekte herumgereicht werden. 
 & Stellt eine weitere Abhängigkeit an ein externes Projekt dar. \\
\hline
Leicht erweiterbar und wartbar.
Integrierte Tab-Navigation.
 & Der aktuelle Zustand ist nicht genau definiert. \\
\hline
Ein Wechsel der View ist mit einem Funktionsaufruf von überall aus möglich. 
 & Die Hintergrundabläufe und der Lebenszyklus sind nicht erkennbar. \\
\hline
\end{tabular}
\caption{Bewertung Navigations-Komponente}
\end{table}

\subsection{Fazit}
Da \brand{React Native} standardmässig keine Tab-Navigation anbietet, wurde React-Native-Router-Flux als Navigations-Variante evaluiert.
Der erste Prototyp mit dem React-Native-Router-Flux erfüllte die Anforderungen.
Alle Views sind an einem Ort im Code festgelegt und es lassen sich bequem weitere hinzufügen.

Während dem Verlauf vom Projekt sind dann aber vermehrt Fehler aufgetreten.
Im Nachhinein wäre es sinnvoller gewesen, die Navigator-Komponente zu verwenden.
Das Verhalten vom React-Native-Router-Flux war nicht voraussehbar.

\section{Karte}
\label{tb-evaluation-karte}

Für die Darstellung der Karte mit \brand{React Native} sind mehrere Varianten ausfindig gemacht worden.

\subsubsection{Variante A: React Native Map Komponente}

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/technischer_bericht/react-native_mapview.png}
	\caption{React Native Map Implementation}
	\label{image-variante-a-map}
\end{figure}

Am \brand{React Native} Meetup wurde ein Blogpost zur \brand{React Native} Map-Komponente\footnote{\url{http://browniefed.com/blog/2015/05/30/create-a-map-with-react-art/}} vorgestellt. Diese Variante steht standardmässig zur Verfügung.

\subsubsection{Variante B: Extended React Native Map Komponente}

\begin{figure}[H]
	\centering
	\includegraphics[width=8cm]{images/technischer_bericht/lelandrichardson_react-native-maps.png}
	\caption{react-native-maps - Marker Verwendung}
	\label{image-variante-b-map}
\end{figure}

Diese Komponente (Extended React Native Map Komponente\footnote{\url{https://github.com/lelandrichardson/react-native-maps}}) wurde von \brand{Facebook} anstelle der Standard MapView-Komponente, von \brand{React Native}, empfohlen.


\subsubsection{Variante C: MapBox GL Library}

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/technischer_bericht/react-native-mapbox-gl.jpg}
	\caption{React Native Mapbox GL - Marker Verwendung}
	\label{image-variante-b-map}
\end{figure}

\brand{MapBox} bietet mit dieser experimentellen \brand{React Native}-Komponente (MapBox GL Library\footnote{\url{https://libraries.io/npm/react-native-mapbox-gl}}) eine weitere Lösung für \brand{iOS} und \brand{Android}.


\subsubsection{Variante D: Portierung von Leaflet nach React}

Für \brand{React} gibt es eine Map-Komponente namens React-Leaflet\footnote{\url{https://github.com/PaulLeCam/react-leaflet}}. 
Das liesse sich für \brand{React Native} portieren.
Schon in der \kort{}-\gls{WebApp} wurde die \brand{Leaflet}\footnote{\url{http://leafletjs.com/t}}-Library verwendet.

\subsubsection{Variante E: Raster-Kacheln selbst darstellen}

Die letzte mögliche Variante war, dass wir die benötigten Raster-Kacheln, die der Benutzer braucht, entsprechend laden und anzeigen.

\begin{table}[H]
\centering
\label{tb-evaluation-map-komponente}
\begin{tabular}{|p{7cm}|p{7cm}|}
\hline
\multicolumn{2}{|c|}{\textbf{Variante A: \brand{React Native} Map Komponente}} \\
\hline
Vorteile & Nachteile \\
\hline
Komponente von \brand{Facebook} - \brand{React Native} & Pattern Fill ist nicht implementiert und auch nicht in Planung.
Dadurch lassen sich keine eigene Marker auf der Kartenansicht darstellen. \\
\hline
 & Es lassen sich keine Map-Kacheln von einem beliebigen Service darstellen.  \\
\hline
\multicolumn{2}{|c|}{\textbf{Variante B: Extended React Native Map Komponente}} \\
\hline
Vorteile & Nachteile \\
\hline
Bietet alle benötigten Funktionen (eigene klickbare Marker platzieren und vieles mehr).
 & Nutzt die native Map API von \brand{Apple iOS} und \brand{Android} SDK. 
 Ist fest mit \brand{Apple} und \brand{Google Maps} verbunden.
Allein die Lizenz von \brand{Google} erlaubt es uns nicht, eigene Marker und andere Elemente auf der Kartenansicht darzustellen. \\
\hline
Wird von \brand{Facebook} empfohlen.
 & Native Map APIs sind für ein \brand{OpenStreetMap}-Projekt aus moralischen Gründen unpassend. \\
\hline
\multicolumn{2}{|c|}{\textbf{Variante C: MapBox GL Library}} \\
\hline
Vorteile & Nachteile \\
\hline
Lässt sich mit Offline-Kacheln von \brand{OSM2VectorTiles}\footnote{\url{http://osm2vectortiles.org/downloads/}} füttern (Vektor Kacheln) & Offline-Untestützung ist problematisch. \\
\hline
 & Experimentelle Komponente. \\
\hline
\multicolumn{2}{|c|}{\textbf{Variante D: Portierung von Leaflet nach React}} \\
\hline
Vorteile & Nachteile \\
\hline
Wäre eine der einzigen Möglichkeiten, falls keine andere Variante in Frage kommt.
 & Darstellung nur im Browser möglich. \\
\hline
\multicolumn{2}{|c|}{\textbf{Variante E: Raster-Tiles selbst darstellen}} \\
\hline
Vorteile & Nachteile \\
\hline
Wäre eine der einzigen Möglichkeiten, falls keine andere Variante in Frage kommt.
 & Zu hoher Aufwand. \\
\hline
\end{tabular}
\caption{Bewertung Map-Komponente}
\end{table}

\subsection{Fazit}

Varianen, die Native Map APIs von \brand{Google} und \brand{Apple} verwenden, kamen für uns nicht in Frage.
Wir möchten mit unserer App \brand{OpenStreetMap} Daten verbessern und setzen somit aus moralischen Aspekten auch auf diese Karten.
Bei der \brand{React Native} Map-Komponente gab es keine Möglichkeit Bilder auf der Karte darzustellen und die Raster-Tiles "von Hand" anzuzeigen wäre schlicht zu aufwendig. 
Es liesse sich auch nur sehr umständlich eine schöne Map designen.

Somit sprang uns als erstes die Portierung von Leaflet für \brand{React} ins Auge. 
Nach dem betrachten vom Code fiel uns aber auf, dass diese Variante eventuell nur möglich ist, wenn die Karte in einer WebView-Komponente von \brand{React Native} dargestellt wird.

Als letzte Möglichkeit blieb die MapBox GL Library.
Diese hat beim Testen auf Anhieb funktioniert und uns überzeugt.
Der einzige Haken wären die Kosten, welche bei einer sehr hohen Benutzeranzahl (ab 50'000 Nutzern) beachtet werden müssen.
Den Gedanken zur Offline-Unterstützung hatten wir auch.
Nur gäbe es da Probleme mit der Grösse der App, da die Vektor-Kacheln und die Missionen im Voraus heruntergeladen und mit installiert werden müssten.

\section{OAuth}
Gebraucht wird ein Login-Dienst für \brand{Google}-, \brand{Facebook}- und \brand{OpenStreetMap}-Konten. 
Für die Authentifizierung wurden diese Möglichkeiten evaluiert:

\subsubsection{Variante A: Auth0}

\brand{Auth0}\footnote{\url{https://github.com/auth0/react-native-lock}} \footnote{\url{https://auth0.com/}} bietet eine Implementation für beliebige \gls{OAuth} 2-Dienste. 

\subsubsection{Variante B: Open-Source-Projekte}

Ein Projekt für die \brand{Google}-Authentifizierung wäre react-native-google-signin\footnote{\url{https://github.com/devfd/react-native-google-signin}}. 
Für \brand{Facebook} bot sich react-native-facebook-login
\footnote{\url{https://github.com/magus/react-native-facebook-login}} an.


\begin{table}[H]
\centering
\label{tb-evaluation-oauth-komponente}
\begin{tabular}{|p{7cm}|p{7cm}|}
\hline
\multicolumn{2}{|c|}{\textbf{Variante A: \brand{Auth0}}} \\
\hline
Vorteile & Nachteile \\
\hline
Sehr einfach Einbindung.
 & Keine \gls{OAuth} 1.0a Unterstützung. \\
\hline
Kostenlos für Open-Source-Projekte.
 & Schlecht erweiterbar mit eigenem Login für \brand{OpenStreetMap}. \\
\hline
\end{tabular}
\caption{Bewertung OAuth-Komponente}
\end{table}


\subsection{Fazit}
\brand{Auth0} kam definitiv nicht in Frage, da es nicht mit einer \gls{OAuth} 1.0a-Authentifizierung, wie sie von \brand{OpenStreetMap} unterstützt wird, erweiterbar ist.
Entschieden haben wir uns für das react-native-google-signin-Projekt.
Es funktioniert auf beiden Plattformen und liefert ein Token, das vom \kort{}-Backend überprüft werden kann.
Der Nachteil ist, dass es kein Open Source Projekt gab, welches alle gewünschten Social-Logins für \brand{iOS} und \brand{Android} anbietet.

\brand{Facebook} wird vom \kort{}-Backend derzeit nicht unterstützt und das react-native-facebook-login-Projekt auf Github liefert auch kein Token, wie es beim \brand{Google}-Login der Fall ist.
Weitere Anpassungen am Backend wären nötig gewesen.
Wir hatten uns dazu entschieden, keine Backend-Anpassungen durchzuführen.


\section{Plattformunabhängigkeit}
Eine Stärke von \brand{React Native} ist die Plattformunabhängigkeit. 
Wenn keine spezifische \brand{Android}- oder \brand{iOS}-Komponenten verwendet werden, kann der Code auch für beide Plattformen genutzt werden.
Also haben wir beim Entwickeln der \brand{Android}-App darauf geachtet, möglichst keine spezifische Komponenten zu nutzen. 
Mit einer Blacklist für Komponenten, die vom React Native Packager\footnote{\url{https://github.com/facebook/react-native/tree/master/packager}} angeboten wird, konnten wir das Maximum an wiederverwendbarem Code herausholen. 
Wenn möglich wurden auch alle Dateien mit der Endung \textit{.android.js} ignoriert, da diese ein davon abweichendes Pendant für \brand{iOS} (mit der Endung \textit{.ios.js}) haben.
