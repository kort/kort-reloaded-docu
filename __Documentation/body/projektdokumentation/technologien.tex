\chapter{Technologien}
\label{pd-technologien}
In diesem Kapitel sind Informationen zur Funktionsweise der Technologien \brand{React} und \brand{React Native} dokumentiert. 
Das Unterkapitel zu \brand{React Native} beschreibt ebenfalls unsere Erfahrungen und Schlüsse.


\section{React} 
\brand{React}\footnote{\url{https://facebook.github.io/react/}, \url{https://github.com/facebook/react}} wurde im März 2013 veröffentlicht\cite{react-release}, ist eine Open Source \brand{JavaScript} \gls{Library} und dient für die Implementation der View vom \gls{MVC}-Pattern. 
Die View besteht aus wiederverwendbaren Komponenten, die wiederum Komponenten beinhalten.
\brand{React} wird von \brand{Facebook}, \brand{Instagram} und von der Community entwickelt und gewartet.\cite{react}

Für \brand{React} wird \gls{JSX}, welches eine HTML ähnliche Syntax nutzt, zur Erstellung der Komponenten empfohlen. 
So lassen sich Komponenten-Bäume direkt mit \brand{JavaScript} erstellen. 
Anders formuliert können \brand{JavaScript}-Objekte mit einer HTML-Syntax erzeugt werden. 
Eine Hauptkomponente gibt seine Daten per Props an die Kind-Komponenten weiter (one-way-dataflow).\cite{react-data-flow}
\gls{JSX} wird nicht zwingend benötigt.\cite{jsx-syntax}

Anstatt der \gls{DOM} nutzt \brand{React} die sogenannte \gls{Virtual DOM}.
Wie der Begriff schon sagt, wird mit einer Abstraktion der echten \gls{DOM} -- also mit einer virtuellen DOM -- kommuniziert.
Die komplette \gls{DOM}, also die Repräsentation der View vom HTML-Code, ist im lokalen Speicher abgelegt.\cite{virtual-dom}
In der \inlinecode{render()}-Methode jeder \brand{React}-Klasse wird eine Beschreibung der DOM zurückgeliefert, die \brand{React} mit der lokalen Kopie der \gls{DOM} vergleicht.
Mit einem sehr effizienten Diffing-Algorithmus berechnet \brand{React} den Unterschied zwischen diesen  Versionen der \gls{DOM} und errechnet den schnellsten Weg um den Browser zu aktualisieren.\cite{react-virtual-dom}


\section{React Native}
Der Ansatz von \brand{React Native}\footnote{\url{https://facebook.github.io/react-native/}, \url{https://github.com/facebook/react-native}} ist \textit{learn once -- write anywhere}, das heisst, lerne eine Technologie und nutze sie für alle unterstützten Plattformen.\cite{react-native}

Am 26. März 2015 wurde \brand{React Native} erstmals für \brand{iOS} veröffentlicht.
Im Oktober 2015 kam \brand{Android} dazu.\cite{react-native-release}
Seit dem Release gibt es alle zwei Wochen eine neue Version. 
Durch diese häufigen Änderungen konnten sich noch keine Best Practices etablieren. 
Auch die meisten Open Source Projekte verfolgen eigene Implementationsansätze.

Eine Desktop Unterstützung für \brand{OSX} ist ebenfalls in Entwicklung\footnote{\url{https://github.com/ptmt/react-native-desktop}}. 
Und am 13. April 2016, an der \brand{Facebook} Developer Konferenz, kündigten \brand{Microsoft} und \brand{Facebook} den Support für die \brand{Universal Windows Platform} (\brand{UWP}) an.\cite{react-native-windows}


\subsection{Layout}
Alle \gls{GUI}-Komponenten befinden sich in sogenannten Containern. 
Ein Container wird durch eine \inlinecode{View}-Komponente definiert. 
Das Layout und die Gestaltung der Container und Komponenten wird mit \brand{Flexbox} geregelt. 

\subsection{Technische Details}
\brand{React Native} nutzt einen \brand{JavaScript}-Layer, beziehungsweise \brand{JavaScriptCore} als Engine, um den Code auszuführen.\cite{react-native-javascriptcore} 
Die native Funktionen werden auf die \brand{JavaScript}-Objekte oder Funktionen gemappt. 
Das Endprodukt ist also keine \gls{WebApp} für den Browser und wird auch nicht in native Code kompiliert. 
Ausserdem wird der \brand{JavaScript}-Code auf einem separaten Thread ausgeführt und nicht auf dem UI-Thread. 
Dadurch wirken zum Beispiel die Animationen sehr flüssig.\cite{react-native-javascript-thread}


\subsubsection{Native Module}
Damit ein \brand{iOS} Native-Modul in \brand{React Native} verwendet werden kann, muss das konkrete Modul das \newline\inlinecode{RCTBridgeModule}-Protokoll\footnote{RCT ist eine Abkürzung für ReaCT} implementieren und das Makro \newline\inlinecode{RCT\_EXPORT\_MODULE()} enthalten. 
Das Protokoll dient nur dazu, das Modul in einem Array zu speichern, damit es später von der Bridge gefunden werden kann. 
Wenn die \brand{JavaScript}-Seite der Bridge initialisiert ist, kann sie auf diese Daten zugreifen. 
Dem Makro kann auf der \brand{JavaScript}-Seite ein optionaler Namen als Parameter mitgegeben werden. 
Falls dieser Parameter fehlt, wird die Komponente auf \brand{JavaScript}-Seite nach dem \brand{Objective-C}-Klassennamen benannt. 
Ein Ähnliches Vorgehen gilt für \brand{Swift}- und \brand{Android}-Module. 
Genauere Hinweise sind in der \brand{React Native}-Dokumentation unter \textit{Native Modules} beschrieben.\cite{react-native-module-ios}\cite{react-native-module-android}
Mit diesem Feature lässt sich bereits vorhandenen native Code wiederverwenden. 
% Für \brand{Android}-Module muss die gewünschte Klasse, die in \brand{React Native} verwendet werden möchte, von der Klasse \inlinecode{ReactContextBaseJavaModule} erben. 
% Das erfordert dann die Implementation der \inlinecode{getName()}-Methode. 
% Diese Methode soll dann den Namen, für die Verwendung der Komponente in \brand{React Native}, zurückgeben. 


\subsection{Setup}
Die Entwicklungsumgebung lässt sich am schnellsten und einfachsten auf \brand{OS X} einrichten. 
\brand{Windows} und \brand{Linux} sind mittlerweile ebenfalls geeignet, was am Anfang dieser Bachelorarbeit nicht der Fall war. 

Mit dem \brand{React Native}-CLI (Command Line Interface) können neue Projekte initialisiert werden und Projekte auf einem Emulator oder einem Gerät getestet werden. 
Nur die \brand{iOS}-App muss über \brand{Xcode} erzeugt werden. 

Die Projektstruktur vom \brand{JavaScript} Code hat vor allem die verwendete \hyperref[pd-architektur]{Architektur} vorgegeben. 
Komponenten der Architektur sind in die entsprechenden Hauptbestandteile eingeordnet. 
Konstanten, IDs und Access-Tokens befinden sich im \inlinecode{Constants}-Ordner. 
Alle \gls{GUI}-Komponenten wurden im \inlinecode{Components}-Ordner erstellt. 


\subsection{Community}
Die Community wirkt sehr zerstreut, denn viele Informationen sind in den Issues vom \brand{React Native} GitHub-Repository\footnote{\url{https://github.com/facebook/react-native/issues}} versteckt.
Ausserdem sind aktuell, am 15.06.2016, 733 offene Issues vorhanden.

\begin{itemize}
	\item Vorhanden ist eine öffentliche, aktive und hilfsbereite \brand{Facebook}-Gruppe\footnote{\url{https://www.facebook.com/groups/react.native.community/}}, mit derzeit ca. 3 500 Mitgliedern.
	\item Es gibt eine \brand{Stack-Overflow}-Kategorie\footnote{\url{http://stackoverflow.com/questions/tagged/react-native}} - leider nur mit wenigen Antworten und Lösungen.
	\item JS.coach\footnote{\url{https://js.coach/}} - listet viele Open Source Projekte auf.
	\item Übersicht über aktuelle Artikel und Blogposts: 
	\begin{itemize}
		\item reactnative.com\footnote{\url{http://www.reactnative.com/}}
		\item \brand{React Native} Newsletter\footnote{\url{http://reactnative.cc/}}
	\end{itemize}
	\item Es ist ebenfalls ein aktiver Subreddit\footnote{\url{https://www.reddit.com/r/reactnative}} vorhanden.
\end{itemize}


\subsection{Zusammenfassung}
Eine Stärke von \brand{React Native} ist die Plattformunabhängigkeit. 
Wenn keine spezifische \brand{Android}- oder \brand{iOS}-Komponenten verwendet werden, kann der Code für beide Plattformen genutzt werden.

Die grössten Hürden von \brand{React Native} sind das Erlernen von\brand{React} und \brand{Flexbox}. 
Denn \brand{Flexbox} für \brand{React Native} unterscheidet sich in vielen Details vom \brand{Flexbox} für Webseiten. 
%Ein wichtiges Detail ist, dass bei \brand{Flexbox} für \brand{React Native} Komponenten nur übereinander (im Z-Index) gerendert werden können, wenn die Anordnung und Reihenfolge der Komponenten in den Containern stimmt. 
Einerseits ist das Grundkonzept für das Layout bei vielen verschachtelten Komponenten schwer zu verstehen. 
Selbst Die Umsetzung von ganz simplen Views ist am Anfang schwer und frustrierend. 
Andererseits wirkt es, nachdem viele Stunden in das Lernen investiert wurden, doch konsistent und praktisch. 
Dazu kommt, dass durch \brand{Flexbox} die definierten Styles gut wiederverwendbar sind. 
Das Gleiche gilt für jegliche Komponenten, die auch gut durch Inspiration aus anderen Open Source Projekten erstellt werden können.
Durch die wachsende Community gibt es immer mehr solcher Projekte, Pull-Requests und Beiträge an \brand{React Native} selber. 
Das macht \brand{React Native}, langfristig gesehen, zu einer immer besseren und wichtigeren Technologie. 

Die Umstellung von der native Entwicklung zu \brand{React Native} ist Anfangs auch schwer. 
Vor Allem wenn Fehler auf \brand{React Native}-Seite existieren, die native elegant und knapp lösbar sind. 
Mit der Zeit zeigen sich aber die grossen Vorteile von \brand{React}-\brand{JavaScript}. 
Jede einzelne Komponente wird allein durch ihren State kontrolliert. 
Je nach State kann die Komponente durch die eigene \inlinecode{render()}-Methode kontrolliert und verändert werden. 

Ein ausschlaggebender Vorteil ist das Live- oder Hot-Reload Feature. 
Nur beim ersten Ausführen der app muss ein Build erstellt werden.
Dank dem gleichzeitigen Starten vom \gls{Packager} kann die Ansicht auf dem Emulator oder dem Smartphone, direkt während dem Programmieren, aktualisiert werden. 
Die Hot-Reload Funktion erlaubt ein manuelles Aktualisieren der App. 

Der App-Showcase, der offiziellen \brand{React Native}-Dokumentation, wächst stetig\footnote{\url{https://facebook.github.io/react-native/showcase.html}}.\cite{react-native-showcase} 
Nach uns werden Apps in Zukunft nur noch mit \brand{React Native} entwickelt.
